
程序文档

最早写unix的人关注的是操作系统的运行效率，加上当时还没有出现gnu c这样的编译器，所以很多优化需要靠c语言去完成，因此源代码中到处充斥着“过早优化”的例子，比如被lions戏称为"本年度最差过程"的namei。

它只有9000行代码，尽管它实现了现代操作系统的几乎所有功能，但unix源代码并不适合拿来教学，更加。

第一是因为unix和机器的紧密结合，。

unix在实现文件系统时使用的几个数据结构。

比如我认为PL/0文法作为编译原理的官方教学文法就非常适合，因为学生能够很快地用它写出一个递归向下的语法分析框架，然后就可以把注意力集中在自己设计的语言身上，逐步加入浮点数，函数，嵌套作用域，而不是在一开始的时候就在纸上设计好语言的每个功能，然后采用瀑布式的开发流程。

所以，


通过写这个程序，最大的感受就是从unix文件系统体现出的trade off。


常用变量说明

dino_no 磁盘inode号
pinode 内存inode指针
sb	内存超级块实例
fd	vfs文件指针


pathname的合法性检查放到上层的Python中去完成

操作系统的一个重要功能就是把一个文件名（pathname）转化成对应的inode，为此需要设立一种目录（directory）数据结构


主要方法说明

unsigned int namei(const char*)

参数：文件名字符串
返回：inode号
说明：负责搜索目录，并且找到pathname对应的inode节点号。


void iput(struct inode_t*)

参数：内存inode指针
说明：删除一个对内存inode的连接，并且使其引用计数器减1


struct inode_t* iget(unsigned int)

参数：inode号
返回：内存inode指针
说明：观察inode是否存在于内存inode表中，如果没有则加入。


struct inode_t* ialloc(void);

返回：内存inode指针

void ifree(unsigned int);

参数：inode号
说明












